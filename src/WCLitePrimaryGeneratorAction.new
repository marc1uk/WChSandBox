#include "WCLitePrimaryGeneratorAction.hh"
#include "WCLiteDetectorConstruction.hh"
#include "WCLitePrimaryGeneratorMessenger.hh"

#include "G4Event.hh"
#include "G4ParticleGun.hh"
#include "G4GeneralParticleSource.hh"
#include "G4ParticleTable.hh"
#include "G4ParticleDefinition.hh"
#include "G4ThreeVector.hh"
#include "globals.hh"
#include "Randomize.hh"
#include <fstream>
#include <vector>
#include <string>
#include "TFile.h"
#include "TRandom3.h"

#include "G4Navigator.hh"
#include "G4TransportationManager.hh"

using std::vector;
using std::string;
using std::fstream;

vector<string> tokenize( string separators, string input );

inline vector<string> readInLine(fstream& inFile, int lineSize, char* inBuf)
{
  // Read in line break it up into tokens
  inFile.getline(inBuf,lineSize);
  return tokenize(" $", inBuf);
}

inline float atof( const string& s ) {return std::atof( s.c_str() );}
inline int   atoi( const string& s ) {return std::atoi( s.c_str() );}

WCLitePrimaryGeneratorAction::WCLitePrimaryGeneratorAction(
					  WCLiteDetectorConstruction* myDC)
  :myDetector(myDC)
{
  //T. Akiri: Initialize GPS to allow for the laser use 
  MyGPS = new G4GeneralParticleSource();

  tcardfile = new TTree("tcardfile","tcardfile");
  tcardfile->Branch("vtxx",&mvtxx); 
  tcardfile->Branch("vtxy",&mvtxy); 
  tcardfile->Branch("vtxz",&mvtxz);
  tcardfile->Branch("px",&mpx); 
  tcardfile->Branch("py",&mpy); 
  tcardfile->Branch("pz",&mpz);
  tcardfile->Branch("KE",&mKE);
  tcardfile->Branch("Nneut",&nneut);
  tcardfile->Branch("np",&np);
  tcardfile->Branch("mode",&mmode);
  tcardfile->Branch("mpid",&mpid);

  mR = new TRandom3();

  // Initialize to zero
  mode = 0;
  vtxvol = 0;
  vtx = G4ThreeVector(0.,0.,0.);
  nuEnergy = 0.;
  _counterRock=0; // counter for generated in Rock
  _counterCublic=0; // counter generated
  
  //---Set defaults. Do once at beginning of session.
  
  G4int n_particle = 1;
  particleGun = new G4ParticleGun(n_particle);
  particleGun->SetParticleEnergy(1.0*GeV);
  particleGun->SetParticleMomentumDirection(G4ThreeVector(0.,0.,1.0));

  G4ParticleTable* particleTable = G4ParticleTable::GetParticleTable();
  G4String particleName;
  particleGun->
    SetParticleDefinition(particleTable->FindParticle(particleName="mu+"));

  particleGun->
    SetParticlePosition(G4ThreeVector(0.*m,0.*m,0.*m));
    
  messenger = new WCLitePrimaryGeneratorMessenger(this);
  useMulineEvt = true;
  useNormalEvt = false;
}

WCLitePrimaryGeneratorAction::~WCLitePrimaryGeneratorAction()
{
  if (IsGeneratingVertexInRock()){
    G4cout << "Fraction of Rock volume is : " << G4endl;
      G4cout << " Random number generated in Rock / in Cublic = " 
             << _counterRock << "/" << _counterCublic 
             << " = " << _counterRock/(G4double)_counterCublic << G4endl;
  }
  inputFile.close();

  TFile *ttttf = new TFile("generatorcardfile.root","RECREATE");
  tcardfile->Write();
  ttttf->Close();

  delete tcardfile;
  delete particleGun;
  delete MyGPS;   //T. Akiri: Delete the GPS variable
  delete messenger;
}

void WCLitePrimaryGeneratorAction::GeneratePrimaries(G4Event* anEvent)
{

  // We will need a particle table
  G4ParticleTable* particleTable = G4ParticleTable::GetParticleTable();

  // Temporary kludge to turn on/off vector text format 

  G4bool useNuanceTextFormat = true;


  // Do for every event

  if (useMulineEvt)
  { 

    if ( !inputFile.is_open() )
    {
      G4cout << "Set a vector file using the command /mygen/vecfile name"
	     << G4endl;
      return;
    }

    if (useNuanceTextFormat)
      {
	const int lineSize=100;
	char      inBuf[lineSize];
	vector<string> token(1);
	
	token = readInLine(inputFile, lineSize, inBuf);
	  
        if (token.size() == 0) 
	  {
	    G4cout << "end of nuance vector file!" << G4endl;
	  }
	else if (token[0] != "begin")
	  {
	    G4cout << "unexpected line begins with " << token[0] << G4endl;
	  }
	else   // normal parsing begins here
	  {
	    // Read the nuance line (ignore value now)

	    token = readInLine(inputFile, lineSize, inBuf);
	    mode = atoi(token[1]);
	    mmode=mode;
	    // Read the Vertex line
	    //	    token = readInLine(inputFile, lineSize, inBuf);

	    /*
	    mvtxx = ((mR->Rndm())-0.5)*190.0;
	    mvtxy = ((mR->Rndm())-0.5)*300.0;
	    mvtxz = ((mR->Rndm())-0.5)*300.0;
	    */

	    mvtxx = 0.;
	    mvtxy = 0.;
	    mvtxz = 0.;

	    vtx = G4ThreeVector(mvtxx*cm,
				mvtxy*cm,
				mvtxz*cm);

	    //	    vtx = G4ThreeVector(atof(token[1])*cm,
	    //				atof(token[2])*cm,
	    //				atof(token[3])*cm);

	    //	    mvtxx = atof(token[1]);
	    //	    mvtxy = atof(token[2]);
	    //	    mvtxz = atof(token[3]);

            // true : Generate vertex in Rock , false : Generate vertex in WC tank
            SetGenerateVertexInRock(false);

	    // Next we read the incoming neutrino and target
	    
	    // First, the neutrino line

	    token=readInLine(inputFile, lineSize, inBuf);
	    beampdg = atoi(token[1]);
	    beamenergy = atof(token[2])*MeV;
	    beamdir = G4ThreeVector(atof(token[3]),
				    atof(token[4]),
				    atof(token[5]));


	    G4cout<<"neutrino line: "<<token[1]<<" "<<token[2]<<" "<<token[3]<<G4endl;

	    // Now read the target line

	    token=readInLine(inputFile, lineSize, inBuf);
	    targetpdg = atoi(token[1]);
	    targetenergy = atof(token[2])*MeV;
	    targetdir = G4ThreeVector(atof(token[3]),
				      atof(token[4]),
				      atof(token[5]));


	    G4cout<<"target line: "<<token[1]<<" "<<token[2]<<" "<<token[3]<<G4endl;


	    // Read the info line, basically a dummy
	    token=readInLine(inputFile, lineSize, inBuf);
	    //G4cout << "Vector File Record Number " << token[2] << G4endl;
            vecRecNumber = atoi(token[2]);
	    
	    // Now read the outgoing particles
	    // These we will simulate.

	    nneut=0;
	    np=0;
	    G4double npl=-555.;

	    while ( token=readInLine(inputFile, lineSize, inBuf),
		    ((token[0] == "track")||(token[0] == "vertex")) )
	      {
		// We are only interested in the particles
		// that leave the nucleus, tagged by "0"
		
		if(token[0]=="track"){

		  G4cout<<"am here yo "<<token[6]<<G4endl;

		  //		  if( token[6]=="0" )
		  if( atoi(token[6])==0 )
		    {
		      G4cout<<"ready to rock...seriously"<<G4endl;

		    G4int pdgid = atoi(token[1]);
		    G4double energy = atof(token[2])*MeV;
		    G4ThreeVector dir = G4ThreeVector(atof(token[3]),
						      atof(token[4]),
						      atof(token[5]));
		    
		    mpx = dir.x();
		    mpy = dir.y();
		    mpz = dir.z();
		    
		    G4cout <<"ParticleMW: "<< pdgid;
		    
		    if(pdgid!=8016){
		      G4cout<<" " <<(particleTable->FindParticle(pdgid))<< G4endl;
		      particleGun->
			SetParticleDefinition(particleTable->
					      FindParticle(pdgid));
		      G4double mass = 
			particleGun->GetParticleDefinition()->GetPDGMass();
		      
		      G4double ekin = energy - mass;
		      G4cout<<"ENERGY: "<<energy<<" "<<mass<<" "<<ekin<<G4endl;
		      
		      if(pdgid==2112){
			nneut++; 
			if(ekin>npl){
			  np = ekin;
			  npl=np;
			}
		      }

		    particleGun->SetParticleEnergy(ekin);
		    //G4cout << "Particle: " << pdgid << " KE: " << ekin << G4endl;
		    mpid = pdgid;
		    mKE = ekin;
		    particleGun->SetParticlePosition(vtx);
		    particleGun->SetParticleMomentumDirection(dir);
		    particleGun->GeneratePrimaryVertex(anEvent);

		    tcardfile->Fill();
		    }
		  }
		} else { G4cout<<"vertex: "<<token[1]<<" "<<token[2]<<" "<<token[3]<<G4endl;}
	      }

	    // Read in MRD data if bobfile=true
	    //	    token = readInLine(inputFile, lineSize, inBuf);
	    if(token[0]=="headerend"){

	      // read in summary line - total depth, total E, total Cherenk E
	      token = readInLine(inputFile, lineSize, inBuf);
	      G4cout<<token[0]<<G4endl;
	      if(token[0]=="T"){
		numlayers =  atoi(token[1]);
		edep = atof(token[2]);
		echdep = atof(token[2]);
		G4cout<<"number of layers: "<<numlayers<<G4endl;
	      } else {
		G4cout<<"PROBLEM WITH FILE!!! No T line"<<G4endl;
	      }
	      
	      G4int layercount=0;

	      while ( token=readInLine(inputFile, lineSize, inBuf),
		      ((token[0] == "V")||(token[0] == "H")) )
		{
		  layercount++;

		  if(token[0]=="V") mrdstrp_orient = 0;
		  if(token[0]=="H") mrdstrp_orient = 1;

		  G4cout<<token[0]<<" "<<token[1]<<" "<<token[2]<<G4endl;

		}

	      //token=readInLine(inputFile, lineSize, inBuf);

	      if(layercount!=numlayers){
		//	G4cout<<"PROBLEM WITH FILE!!! numlayers don't match"<<G4endl;
	      }

	    } else {
	      G4cout<<"PROBLEM WITH FILE!!! No end Header"<<G4endl;
	    }


	  }
      }
    else 
      {    // old muline format  
	inputFile >> nuEnergy >> energy >> xPos >> yPos >> zPos 
		  >> xDir >> yDir >> zDir;
	
	//	G4double random_z = ((myDetector->GetWaterTubePosition())
	//			     - .5*(myDetector->GetWaterTubeLength()) 
	//			     + 1.*m + 15.0*m*G4UniformRand())/m;
	
	G4double random_z = 55.;
	zPos = random_z;
	G4ThreeVector vtx = G4ThreeVector(xPos, yPos, random_z);
	G4ThreeVector dir = G4ThreeVector(xDir,yDir,zDir);

	particleGun->SetParticleEnergy(energy*MeV);
	particleGun->SetParticlePosition(vtx);
	particleGun->SetParticleMomentumDirection(dir);
	particleGun->GeneratePrimaryVertex(anEvent);
      }
  }

  else if (useNormalEvt)
  {      // manual gun operation
    particleGun->GeneratePrimaryVertex(anEvent);

    G4ThreeVector P  =anEvent->GetPrimaryVertex()->GetPrimary()->GetMomentum();
    G4ThreeVector vtx=anEvent->GetPrimaryVertex()->GetPosition();
    G4double m       =anEvent->GetPrimaryVertex()->GetPrimary()->GetMass();
    G4int pdg        =anEvent->GetPrimaryVertex()->GetPrimary()->GetPDGcode();

    G4ThreeVector dir  = P.unit();
    G4double E         = std::sqrt((P.dot(P))+(m*m));

//     particleGun->SetParticleEnergy(E);
//     particleGun->SetParticlePosition(vtx);
//     particleGun->SetParticleMomentumDirection(dir);

    SetVtx(vtx);
    SetBeamEnergy(E);
    SetBeamDir(dir);
    SetBeamPDG(pdg);
  }
  else if (useLaserEvt)
    {
      //T. Akiri: Create the GPS LASER event
      MyGPS->GeneratePrimaryVertex(anEvent);
      
      G4ThreeVector P   =anEvent->GetPrimaryVertex()->GetPrimary()->GetMomentum();
      G4ThreeVector vtx =anEvent->GetPrimaryVertex()->GetPosition();
      G4int pdg         =anEvent->GetPrimaryVertex()->GetPrimary()->GetPDGcode();
      
      G4ThreeVector dir  = P.unit();
      G4double E         = std::sqrt((P.dot(P)));
      
      SetVtx(vtx);
      SetBeamEnergy(E);
      SetBeamDir(dir);
      SetBeamPDG(pdg);
    }
}

// Returns a vector with the tokens
vector<string> tokenize( string separators, string input ) 
{
  unsigned int startToken = 0, endToken; // Pointers to the token pos
  vector<string> tokens;  // Vector to keep the tokens
  
  if( separators.size() > 0 && input.size() > 0 ) 
    {
    
      while( startToken < input.size() )
	{
	  // Find the start of token
	  startToken = input.find_first_not_of( separators, startToken );
      
	  // If found...
	  if( startToken != input.npos ) 
	    {
	      // Find end of token
	      endToken = input.find_first_of( separators, startToken );
	      if( endToken == input.npos )
		// If there was no end of token, assign it to the end of string
		endToken = input.size();
        
	      // Extract token
	      tokens.push_back( input.substr( startToken, endToken - startToken ) );
        
	      // Update startToken
	      startToken = endToken;
	    }
	}
    }
  
  return tokens;
}

